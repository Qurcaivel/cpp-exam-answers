# Ответы на экзамен по ПнаЯВУ

## 001 Абстрактные типы данных


_Абстрактные типы данных_ - это набор, включающий в себя данные и выполняемые над ним операции.


## 002 Базовые принципы объектно-ориентированного программирования


_Абстракция (данных)_ - это выделения набора наиболее значимых характеристик объекта, доступных программе.

_Инкапсуляция_ - это свойство системы, позволяющее объединить данные и поведение в единый компонент, разделяя его на две обособленные части - интерфейс и реализацию.

_Наследование_ - это свойство системы, позволяющее абстрактному типу данных наследовать данные и функциональность некоторого существующего типа, тем самым обеспечивая повторное использование компонентов программного обеспечения.

_Полиморфизм (подтипов)_ - это свойство системы, позволяющее использовать объекте с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

_Обмен сообщениями_ - это способ передачи управления объекту с помощью методов.


## 003 Основные достоинства языка C++


- Поддержка ООП.

- Высокая скорость вследствие низкой стоимости абстракций стандартной библиотеки.

- Возможность работы с данными как на низком, так и на высоком уровне.

- Развивающийся стандарт языка, а также сторонние библиотеки от сообщества.

- Высокая обратная совместимость с языком C.

- Повсеместная распространенность и универсальность.


## 004 Особенности языка C++


...


## 005 Ключевые слова


...


## 006 Константы и переменные


_Константа_ - это величина, которая при выполнении программы остается неизменной.

_Переменная_ - это ячейка памяти для временного хранения данных.

Для объявления _констант_ используется модификатор памяти `const`.

Пример:
```c++
const int x = 10; // объявление константы `x`

unsigned long number = 123; // объявление переменной `number`
```


## 007 Операции


...


## 008 Типы данных


В языке C++ можно выделить следующие основные типы данных:
1. логический тип;
2. целочисленные типы;
3. числа с плавающей запятой;
4. строковые типы;
5. указатели;
6. абстрактные типы данных.

### Логический тип

Под _логическим_ типом в языке C++ понимают тип данных `bool`.

Размер типа данных `bool` составляет 1 байт и представлен двумя значениями `true` (истина) и `false` (ложь).

Для логического типа данных существуют специальные _логические_ операции, однако на уровне языка он воспринимается как целочисленный тип.

### Целочислкенные типы

В языке C++ существуют следующие целочисленные типы:
`char (1 байт)`, `short (2 байт)`, `long (4 байт)`, `long long (8 байт)`.

При помощи ключевых слов `signed` и `unsigned` целочисленный тип может быть определен как знаковый и беззнаковый соответственно. 

По умолчанию все целочисленные типы являются знаковыми.

### Числа с плавающей запятой

В языке C++ существуют следующие типы для чисел с плавающей запятой:
`float (4 байт)`, `double (8 байт)`, `long double`.

Типу `float` соответствуют числа с плавающей запятой одинарной точности, `double` - числа с плавающей запятой двойной точности.

Размер и диапазон значения `long double` не определен стандартом и зависит от реализации компилятора.

### Строковые типы

Для представления строк в языке C++ используются абстракции стандартной библиотеки наподобие `std::string`, однако под строковым типом понимают строки, доставшиеся C++ от языка C.

Именно по этой причине в языке C++ существует присваивание строкового литерала переменной типа `const char*`.

### Указатели

Еще одним низкоуровневым типом данных, доставшимся языку С++ от языка С являются _указатели_.

Под указателем понимают переменную, которая хранит адрес памяти, на которую она указывает.

Пример объявления указателя:
```c++
const char* x = "some text"; // указатель на строковый литерал

void (*func_ptr)(int) = func; // указатель на функцию void(int)
```

Примечание 1: для указания на область памяти без приведения типа используется указатель вида `void*`.

Примечание 2: для указания на функцию, не содержащую аргументов, в её параметрах необходимо написать `void`.

### Абстрактные типы данных

Под _абстрактными типами данных_ понимают составные типы, определяемые самим пользователем.

К таким типам относятся _классы_, _структуры_, _объединения_ и _перечисления_.

Ниже представлен пример объявления абстрактного типа данных _Point_, представляющего собой точку на плоскости:
```c++
class Point {
public:
    Point(double x, double y);
    Point(const Point& other);
    
    double x();
    double y();
    double distance(const Point& other);

private:
    double m_x;
    double m_y;
}
```


## 009 Передача аргументов в функцию по умолчанию


_Передача аргументов в функцию по умолчанию_ - это механизм, позволяющий опустить аргумент функции, полагая, что для него существует некоторое _определенное по умолчанию_ значение.

Общая форма объявления функции, которая использует аргументы по умолчанию:

```c++
type func_name(type1 v1 = val1, ..., typeN vN = valN){
    // something
}
```

Примечание: аргументы по умолчанию должны следовать после аргументов без предопределенного значения.


## 010 Простейший ввод и вывод


Стандартный ввод и вывод в языке C++ реализован с помощью потоков ввода-вывода.

Поток ввода по умолчанию: `std::cin`.

Поток вывода по умолчанию: `std::cout`. 


## 011 Объект cin


...


## 012 Объект cout


...


## 013 Манипуляторы ввода/вывода


Манипуляторы ввода/вывода реализованы в стандартной библиотеке `<iomanip>`.

Манипуляторы применяются к потоку с помощью оператора `operator>>` и устанавливают соответствующие их действию флаги.

Основные манипуляторы:
1. `boolalpha`, `noboolalpha` - формат вывода логического типа;
2. `showbase`, `noshowbase` - отображение системы счисления чисел;
3. `showpoint`, `noshowpoint` - отображение незначащих нулей;
4. `showpos`, `noshowpos` - отображение знака числа;
5. `unitbuf`, `nounitbuf` - очистка буфера после каждого взаимодействия;
6. `internal`, `left`, `right` - расположение числа в области вывода;
7. `dec`, `hex`, `oct` - система счисления числа;
8. `fixed`, `scientific`, `hexfloat`, `defautfloat` - представление числа;
9. `ws` - игнорировать лидирующие пробелы;
1. `ends` - вывод символа-терминала;
2. `flush` - очистка буфера;
3. `endl` - вывод переноса строки и очистка буфера;
4. `setbase` - установка определенной системы счисления;
5. `setfill` - установка символа-заполнителя;
6. `setprecision` - установка точности числа с плавающей запятой;
7. `setw` - установка ширины поля вывода;
8. `quoted` - режим цитирования для ввода строки.


## 014 Операторы для динамического выделения и освобождения памяти (new и delete)


Оператор `new` выделяет память, в случае переполнения кучи вызывает std::bad_alloc.

Оператор `delete` очищает выделенную память.


## 015 Объекты


_Объект_ - это сущность в цифровом пространстве, появляющаяся при создании экземпляра класса, обладающая состоянием и поведением, имеющая поля и методы.


## 016 Понятие класса


_Класс_ - это модель для создания объектов определенного типа, описывающая их структуру и определяющая методы для работы с этими объектами.


## 017 Конструктор с параметрами, конструктор по умолчанию


Конструктор по умолчанию `Clazz() = default`
создает экземпляр класса с полями по умолчанию.

Конструктор с параметрами `Clazz(...)` создает экземпляр класса, для инициализации полей которого использует аргументы, переданные
пользователем.


## 018 Деструктор
 

Декструктор `~Clazz()` вызывается при удалении объекта (в результате вызова оператора delete() либо выхода переменной объекта из области видимости).


## 019 Конструктор копирования


Конструктор копирования `Clazz(const &Clazz)` выполняет создание копии объекта, переданного по константной ссылке.

Вызывается:
- при объявлении объекта с одновременной инициализацией данными другого объекта через operator=();
- когда необходимо передать объект в функцию как параметр-значение (копию);
- когда нужно вернуть объект из функции по значению (полная копия объекта).


## 020 Конструктор explicit


Ключевое слово `explicit` определяет конструктор, который не может использоваться для _неявного_ преобразования типов.

Пример:
```c++
class Box {
public:
    explicit Box(int v);

private:
    const int m_v;
}

int main(){
    Box box = 10; // данный код вызовет ошибку
    Box box = static_cast<Box>(10);
}
```

Примечание: в общем случае `exlicit` запрещает неявное приведение типов для всех методов класса, например, его использование для операторов приведения типа запрещает приводить объект класса к данному типу неявно.

Пример:
```c++
class Box {
public:
    explicit Box(int v);
    explicit operator int();

private:
    const int m_v;
}

int main(){
    Box box = Box(10);

    int number = box; // данный код вызовет ошибку
    int number = static_cast<int>(box); 
}
```


## 021 Указатель this


Указатель `this` содержит адрес на объект данного класса.

Чаще всего используется для внутренного обращения к полю тогда, когда возникает конфликт имен локальной переменной и имени данного поля.


## 022 Встроенные функции (спецификатор inline)


Спецификатор `inline` указывает компилятору заменить код в определении функции для каждого экземпляра вызова функции.


## 023 Организация внешнего доступа к локальным компонентам класса (спецификатор friend)


Спецификатор `friend` обеспечивает внешний доступ к внутренним полям экземпляра класса.

Возможны _friend-классы_, а также _friend-функции_.

Чаще всего спецификатор `friend` использется для объявления дружественных бинарных операторов:
```c++
class Point {
public:
    Point(double x, double y);
    Point(const Point& other);

    friend ostream& operator>>(ostream& os, const Point& point);B
}
```


## 024 Дружественные классы


_Поведение дружественных классов описано в пункте 23._

Friend-класс получает доступ ко всем полям данного класса.

Пример:
```c++
class Point {
public:
    Point(double x, double y);
    Point(const Point& other);


private:
    // Класс Canvas может обращаться к полям m_x, m_y класса Point 
    friend class Canvas;
    const double m_x , m_y;
}
```


## 025 Вложенные классы


_Вложенным классом_ называется класс, определенный внутри данного класса.

Действует по отношению к полям внешного класса также, как и _friend-класс_, но определяется в пространстве имен данного класса и можеть быть скрыт извне с помощью модификатора доступа private.

Пример:
```c++
class vector {
public:
    ...

private:
    ...
    // Классы node и iterator являются вложенными классами vector
    class node;
    class iterator;
}
```


## 026 Static-члены (данные) класса


Ключевое слово `static` является указанием на время жизни объекта.

После объявления _static-переменной_ она продолжает существовать по конца работы программы, даже если _static-переменная_ вышла из области видимости.

Ключевое слово `static` по отношению к полям класса определяет переменную, принадлежащую не её экземплярам, а имени класса в целом.


## 027 Компоненты-функции static и const


Описание модификатора `static` по отношению к компонент-функциям описано в пункте 26.

Модификатор `static` определяет метод класса не как метод его экземпляра, а как функцию, определенную в его имени.

Модификатор `const` после сигнатуры компонент-функции указывает на неизменяемость внутренного состояния объекта этим методом 

Примечание: модификатор `const` не запрещает изменять поля с модификаторами `mutable` и `static`.


## 028 Proxy-классы


_Proxy-класс (паттерн 'Заместитель')_ - это класс, который предоставляет модифицированный интерфейс другого класса.

_Proxy-паттерн_ используется для создания посредника, который действует как интерфейс по отношению к другому ресурсу.

В отличие от _Adapter-паттерна_ не расширяет интерфейс, а оставляет его прежним.

Пример:
```c++
class Abstract {
public:
    virtual void process() = 0;
    virtual ~Abstract() = 0;
}

class Impl : public Abstract {
    Impl(){
        // загрузка очень больших данных
    }

    ~Impl() override {
        // выгрузка очень больших данных
    }

    void process() override {
        // обработка очень больших данных
    }
}

class Proxy : public Abstract {
public:
    Proxy(){}
    ~Proxy() override {}

    void process() override {
        if(!m_abstract){
            this->m_abstract = new Impl();
        }
        m_abstract.process();
    }

private:
    Abstract* m_abstract = nullptr;
}

int main(){
    // создание объекта не повлечет загрузку очень больших данных
    Abstract abstract = Proxy();
    // загрузка очень больших данных произойдет здесь
    abstract.process();
    // начиная с этого момента данные считаются загруженными
    abstract.process();
}
```


## 029 Ссылки


_Ссылка_ - это переменная, адресующая существующий в памяти объект.

Из определения ссылок следует, что не существует _нулевых ссылок_, а сама ссылка должна быть инициализирована.

_Const-ссылка_ - это ссылка на константу, имеет вид `const T &name`, предоставляет доступ только для чтения.

_Lvalue-ссылки_ - это стандартная ссылка на объект.

_Rvalue-ссылки_ - это разновидность ссылок, 
которая появилась в C++11.

_Rvalue-ссылка_ определяется как `T &&rv = init_expression` и используется в _move-семантике_.


## 030 Параметры-ссылки


_Параметры-ссылки_ используются для передачи в функцию значений по ссылке.

Пример:
```c++
std::string concat(const std::string& a, const std::string& b);
```


## 031 Пространства имен


_Пространство имен_ - это декларативная область, в рамках которой определяются различные идентификаторы (имена типов, функций, переменных, ...).

Используются для видимого разграничения различных идентификаторов, а также для разрешения возможных конфликтов имен.

Пример:
```c++
namespace type {
    inline bool is_digit(char c);
    inline bool is_alpha(char c);
}
```


## 032 Определение пространства имен


_Определение пространства имен продемонстрировано в примере к пункту 31_.


## 033 Ключевое слово using как директива


_Using-директивы_ используются для подключения идентифаторов пространства имен в общее пространство имен.

Пример: 
```c++
using namespace std;
```


## 034 Ключевое слово using как объявление


_Using-объявление_ используется для для включения идентификатора из пространства имен в общую область видимости.

Пример:
```c++
using std::cin;
```


## 035 Псевдоним пространства имен


Пространствам имен можно давать псевдонимы:
```c++
namespace preudo = name;
```
Примечание: ключевое слово `using` можно использовать для задания имен-синонимов (псевдонимов).

Пример:
```c++
using integer = unsigned int;
```


## 036 Наследование


_Наследование_ - концепция объектно-ориентированного программирования, согласно которой абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использованию компонентов программного обеспечения. 

В языке C++ существует три вида наследования `public`, `private` и `protected`.

В зависимости от типа наследования, методы и поля базового класса получают определенные спецификаторы доступа в производном классе.

Ниже представлена таблица преобразования спецификаторов доступа в зависимости от типа наследования.

| Тип наследования | public    | private  | protected | 
|:-----------------|:----------|:---------|:----------|
| public           | public    | private  | protected |   
| private          | private   | private  | private   |   
| protected        | protected | private  | protected |

В языке C++ реализован принцип множественного наследования:
производный класс может быть унаследован от нескольких базовых классов.


## 037 Наследование (производные классы)


_Производным_ называется класс, унаследованный от другого класса, и, как правило, расширенный собственными данными и поведением.

Пример:
```c++
class Figure {
public:
    Figure(double x, double y);

    double center_x() const;
    double center_y() const;

private:
    double m_x, m_y;
}

class Circle : public Figure {
public:
    Circle(double x, double y, double r) : Figure(x, y);

    // методы center_x() и center_y() унаследованы

    double radius() const;
    double square() const;
    double length() const;

private:
    double m_r;
}
```


## 038 Конструкторы и деструкторы при наследовании


Механизм вызовы конструкторов и деструкторов при наследовании работает следующим образом:
1. конструкторы вызываются от базового класса к производному;
2. деструкторы вызываются от производного класса к базовому.

Данный принцип позволяет соблюдать очередность инициализации и удаления данных, тем самым обеспечивая корректную работу логики конструкторов и деструкторов при создании и удалении объектов.


## 039 Виртуальные функции
 

_Виртуальными_ называются функции, чье поведение определено не на уровне компиляции, а на уровне _времени выполнения программы_.

В языке C++ данный механизм основывается на VMT (virtual method table - таблица виртуальных методов).

Если в классе определены функции с модификатором `virtual`, то объект этого класса содержит поля, каждое из которых хранит указатель на соответствующий метод в _таблице виртуальных методов_.

Случай, когда функция `virtual` не реализует поведения по умолчанию, называется объявлением _чисто виртуальной функции_.

Пример объявления класса с чисто виртуальной функцией:
```c++
class Figure {
public:
    Figure(double x, double y);

    double x() const;
    double y() const;
    virtual double square() const = 0;

private:
    double m_x, m_y;
}
```

Примечание: невозможно создать экземпляр класса, содержащего чисто виртуальную функцию.


## 040 Абстрактные классы


_Абстрактным_ называется такой класс, который содержит хотя бы одну _чисто виртуальную функцию_.

Как уже и было сказанно в _пункте 39_, невозможно создать экземпляр абстрактного класса.

Абстрактный класс лишь определяет таблицу виртуальных методов, которая будет заполняться его потомками.

Абстрактный класс можно использовать как тип, обобщающий все производные от него классы.

Пример:
```c++
class Rectangle : public Figure {
public:
    Square(double x, double y, double a, double b);

    double a() const;
    double b() const;
    double square() const override;
};

class Circle : public Figure {
public:
    Circle(double x, double y, double r);

    double r() const;
    double square() const override;
}
```


## 041 Виртуальные деструкторы


В языке C++ деструктор _полиморфного_ базового класса должен объявляться _виртуальным_.

Такое требование обеспечивает правильное разрушение объекта производного класса через указатель на таблицу виртуальных методов (деструктора).

Пример:
```c++
class Storage {
public:
    Storage(unsigned int size) : m_size(size){}
    virtual ~Storage() = 0;

private:
    unsigned int m_size;
}

class Array : public Storage {
public:
    Array(unsigned int size, const int* e) 
         : Storage(size)
    {
        m_storage = new int[size];
        
        for(int i = 0; i < size; i++){
            m_storage = e[i];
        }
    }

    ~Array(){
        delete m_storage;
    }

private:
    int* m_storage;
}

class Mapping : public Storage {
public:
    Mapping(unsigned int size, const int* a, const int* b) 
           : Mapping(size)
    {
        m_keys = new int[size];
        m_values = new int[size];

        for(int i = 0; i < size; i++){
            m_keys = a[i];
            m_values = b[i];
        }
    }

    ~Mapping(){
        delete m_keys;
        delete m_values;
    }

private:
    int* m_keys, m_values;
}
```

Примечание: _полиморфным_ называется класс, использующий модификатор `virtual`.


## 042 Динамическое и статическое связывание


В контексте компилируемых языков _связывание_ - это связь между вызовом функции и определением функции. 

Когда функция вызывается в C++, управление программой привязывается к адресу памяти, где эта функция определена.

В языке C++ существует два вида привязки (связывания):
1. статическое (раннее);
2. динамическое (позднее).

Ниже перечислены ключевые особенности динамического и статического связывания:

1. Статическая привязка происходит во время компиляции, а динамическая привязка — во время выполнения.

2. При статической привязке определение функции и вызов функции связываются во время компиляции, тогда как при динамической привязке вызовы функций не разрешаются до времени выполнения. 

3. Статическая привязка происходит, когда вся информация, необходимая для вызова функции, доступна во время компиляции. Динамическое связывание происходит, когда компилятор не может определить всю информацию, необходимую для вызова функции, во время компиляции.

4. Статическая привязка может быть достигнута с помощью обычных вызовов функций, перегрузки функций и перегрузки операторов, тогда как динамическая привязка может быть достигнута с использованием виртуальных функций.

5. Статическая привязка приводит к более быстрому выполнению программы. В отличие от статического связывания вызов функции не разрешается до времени выполнения для последующего связывания, что приводит к несколько более медленному выполнению кода.

6. Основным преимуществом динамического связывания является его гибкость, поскольку одна функция может обрабатывать различные типы объектов во время выполнения. Это значительно уменьшает размер кодовой базы, а также делает исходный код более читабельным.

Пример статического связывания:
```c++
class Computer
{
public:
    static int sum(int x, int y){
        return x + y;
    }

    static int sum(int x, int y, int z){
        return x + y + z;
    }
};

int main(){
    int sum2 = Computer.sum(1, 2);
    int sum3 = Computer.sum(1, 2, 3);
}
```

Пример динамического связывания:
```c++
class Base {
public:
    virtual void process(){
        cout << "The base class function is called.\n";
    }
};
 
class Derived: public Base {
public:
    void process() override {
        cout << "The derived class function is called.\n";
    }
};
 
int main()
{
    Base base;
    Derived derived;
 
    Base* base_ptr = &base;
    base_ptr->process();
 
    base_ptr = &derived;
    base_ptr->process();
 
    return 0;
}
```

Ниже представлен результат выполнения примера с динамическим связыванием:
```
The base class function is called.
The derived class function is called.
```

Как видно выше, несмотря на вызов метода `process()` для указателя на объект типа `Base`, во втором случае сработало поведение класса `Derived`, так как перед вызовом метода произошло динамическое связывание по указателю.


## Множественное наследование


Как было упомянуто в _пункте 36_, в языке C++ реализован  механизм множественного наследования.

Суть данного механизма заключается в том, что производный класс может быть унаследован более чем от одного базового класса.

Пример:
```c++
class Functional {
public:
    virtual void execute() = 0;
} 

class Temporary {
public:
    virtual void remove() = 0;
}

class Lambda : public Functional, public Temporary {
public:
    void execute() override;
    void remove() override;
}
```

Множественное наследование обладает рядом видимых преимуществ, таких как наследование поведения от нескольких классов,
однако порождает некоторые проблемы.

Примером такой проблемы является _ромбовидное наследование_: при данном виде множественного наследования производный класс образуется от базовых, которые в свою очередь связаны отношением наследования с общим родителем.

Пример ромбовидного наследования:
```c++
class Serializable {
public:
    virtual std::string to_string() = 0;
};

class Man : public Serializable {
public:
    std::string to_string() override {
        return "man";
    }
};

class Profession : public Serializable {
public:
    std::string to_string() override {
        return "profession";
    }
};

class Worker : public Man, public Profession {
public:
    std::string to_string() override {
        return "worker";
    }
};

int main(){
    Worker worker;
    std::cout << worker.to_string() << std::endl
              << worker.Man::to_string() << std::endl
              << worker.Profession::to_string() << std::endl;
}
```

Ниже представлен результат выполнения программы с ромбовидным наследованием:
```
worker
man
profession
```

В результате экземпляр класса `Worker` содержит для экземпляра класса `Serializable`: один экземпляр от `Man` и один экземпляр от `Profession`.

Таким образом, экземпляры данных классов имеют следующие размеры:
- `sizeof(Man) = 8 bytes`,
- `sizeof(Profession) = 8 bytes`,
- `sizeof(Worker) = 16 bytes`.

Проблема ромбовидного наследования может быть решена несколькими способами, в том числе и при помощи _виртуального наследование_,
которое описано в _пункте 44_.


## 044 Виртуальное наследование


...


## 045 Перегрузка функций


...


## 046 Перегрузка операторов


...


## 047 Перегрузка бинарного оператора


...


## 048 Перегрузка унарного оператора


...


## 049 Дружественная функция operator
 

...


## 050 Особенности перегрузки операции =


...


## 051 Перегрузка оператора []


...


## 052 Перегрузка оператора ()


...


## 053 Преобразование типов


...


## 054 Явные преобразования типов


...


## 055 Преобразования типов, определенных в программе


...


## 056 Параметризированные классы


...


## 057 Передача в шаблон класса дополнительных параметров


...


## 058 Шаблоны функций


...


## 059 Совместное использование шаблонов и наследования


...


## 060 Организация ввода/вывода


...


## 061 <Данный вопрос отсутствует>


...


## 062 Организация ввода/вывода, потоки. Перегрузка операторов ввода и вывода


...


## 063 Функция get() с тремя параметрами


...


## 064 Функция get() без параметров и с одним параметром


...


## 065 Функция getline()


...


## 066 Состояние потока


...


## 067 Функции чтения состояния потока


...


## 068 Организация работы с бинарными файлами. Запись объектов в файл и чтение объектов из файла


...


## 069 Организация работы с файлами последовательного доступа. Запись объектов в файл и чтение объектов из файла


...


## 070 Организация работы с файлами произвольного доступа. Запись объектов в файл, чтение объектов из файла, перезапись объектов в файле


...


## 071 Функции позиционирования в файле


...


## 072 Абсолютный обработчик


...


## 073 Основы обработки исключительных ситуаций


...


## 074 Перенаправление исключительных ситуаций


...

## 075 Исключительная ситуация, генерируемая оператором new


Если для запроса на выделение недостаточно памяти, в `operator new` возникает исключение `std::bad_alloc` или возвращается `nullptr`, если была использована форма `new(std::nothrow)`.

В более некоторых версиях компиляторов возможно неопределённое поведение.


## 076 Генерация исключений в конструкторах


<!-- Подробнее: https://pro-prof.com/forums/topic/constructor_destructor_exceptions. -->

...


## 077 Задание собственной функции завершения


Если не был найден ни один подходящий обработчик исключения, то вызывается стандартная функция `terminate()`, которая, в свою очередь, вызывает функцию `abort()` для завершения работы с приложением.

Для задания своей функции завершения её необходимо зарегистрировать с помощью функции `set_terminate()`, которая будет выполняться перед аварийным завершением работы.

Пример:
```c++
void MyTerminate(){
	std::cout << "An error occured!" << std::endl;
	exit(-1);
}

int main (){
	set_terminate(MyTerminate);
	throw 0;
}
```


## 078 Спецификации исключительных ситуаций


_Спецификации исключений_ — это функция языка C++, которая указывает на намерение программиста определить типы исключений, которые могут распространяться функцией. Также компилятор может использовать это для оптимизации.

Пример:

```c++
void foo1(int i) noexcept; // не вызывает исключений

void foo2(int i) throw(...) // может вызывать исключения любого типа

void foo3(int i) throw(type) // может вызвать исключение типа type
```

Также для данных спецификаторов существуют эквивалентные записи:
- `noexept` ~ `noexept(true)` ~ `throw()`;
- `throw(...)` ~ `noexept(false)`.

Примечание: спецификация `throw(...)` была нерекомендуема начиная со стандарта С++11 и удалена в С++17.


## 079 Правила поиска обработчика исключительных ситуаций


<!-- Поиск обработчика ошибок начинается с текущего оператора `try`, если обработчик ошибок `catch` не был найден для текущего оператора `try`, то ошибка передаётся во внешний оператор `try`, так происходит до тех пор пока не будет обнаружен подходящий обработчик, если же внешний оператор try не будет обнаружен, то вызывается функция terminate(). -->

...


## 080 Механизм развертывания стека


_Развертывание стека_ – это процесс вызова деструкторов локальных объектов, когда исключительные ситуации выводят их из области видимости.

Вызов деструкторов осуществляется по правилу стека, т.е. деструктор последнего созданного объекта будет вызван первым.

Пример:

```c++
#include <limits.h>
#include <iostream.h>

class add_class { 
private:
    unsigned short num;

public:
    add_class(unsigned short a){ 
        num = a;
    	cout << "Constructor " << num << endl;
    }

    ~add_class(){ 
		cout << "Destructor " << num << endl; 
	}

    void show_num(){
		cout << " " << num << " "; 
	}

    void input_num(unsigned short a){ 
		num = a; 
	}

    unsigned short output_num(){
		return num;
	}
};

add_class add(add_class a,add_class b){ 
    add_class sum(0);
    unsigned long s = (unsigned long)a.output_num()+ 
                      (unsigned long)b.output_num();

    if(s > USHRT_MAX) throw (int) 1;

    sum.input_num((unsigned short) s);
    return sum;
}

void main(){ 
    add_class a(USHRT_MAX), b(1), s(0);

    try {
        s = add(a, b);
        cout << "Result";
        s.show_num();
        cout << endl;
    } 
	catch(int){
        cout << "Overflow error" << endl;
    }
}
```

Результат выполнения программы:
```
Constructor 65535
Constructor 1
Constructor 0
Constructor 0
Destructor 0
Destructor 65535
Destructor 1
Overflow error
Destructor 0
Destructor 1
Destructor 65535
```


## 081 Иерархия исключений стандартной библиотеки


...


## 082 Общее понятие о контейнере


...


## 083 Общее понятие об итераторе


...


## 084 Категории итераторов


...


## 085 Основные итераторы: итераторы ввода/вывода


...


## 086 Вспомогательные итераторы


...


## 087 Операции с итераторами


...


## 088 <Данный вопрос отсутствует>


...


## 089 Контейнеры последовательностей


...


## 090 Контейнер последовательностей vector


...


## 091 Контейнер последовательностей list


...


## 092 Контейнер последовательностей deque


...


## 093 Ассоциативные контейнеры


...


## 094 Ассоциативный контейнер set


...


## 095 Ассоциативный контейнер multiset


...


## 096 Ассоциативный контейнер map


...


## 097 Ассоциативный контейнер multimap


...


## 098 Адаптер stack


...


## 099 Адаптер queue


...


## 100 Адаптер priority_queue


...


## 101 STL-алгоритмы


STL-алгоритмы являются одной из основных сущностей STL и представляют собой наиболее часто используемые на практике алгоритмы, которые можно применить к шаблонным типам.

Примерами таких алгоритмов являются общие для всех контейнеров алгоритмы поиска, сортировки, обмена данных, а также такие специальные алгоритмы как бинарный поиск и слияние упорядоченных последовательностей.


## 102 Алгоритмы сортировки sort


Алгоритм `sort` - алгоритм STL, выполняющий упорядочивание последовательности по заданному компаратору:
```c++
// сортировка по умолчанию (по неубыванию значений представления)
template<class RandomIt>
void sort(RandomIt first, RandomIt last);

template<class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
```

Пример использования:
```c++
#include <algorithm>
#include <functional>
#include <array>
#include <iostream>
#include <string_view>
 
int main()
{
    std::array<int, 10> s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3};
 
    auto print = [&s](std::string_view const rem)
    {
        for(auto a : s){
            std::cout << a << ' ';
        }
        std::cout << ": " << rem << '\n';
    };
 
    std::sort(s.begin(), s.end());
    print("sorted with the default operator '<'");
 
    std::sort(s.begin(), s.end(), std::greater<int>());
    print("sorted with the STL compare function object");
 
    struct{
        bool operator()(int a, int b) const { return a < b; }
    }
    customLess;
 
    std::sort(s.begin(), s.end(), customLess);
    print("sorted with a custom function object");
 
    std::sort(s.begin(), s.end(), 
    [](int a, int b){
        return a > b;
    });
    print("sorted with a lambda expression");
}
```

Результат выполнения программы:
```
0 1 2 3 4 5 6 7 8 9 : sorted with the default operator '<'
9 8 7 6 5 4 3 2 1 0 : sorted with the STL compare function object
0 1 2 3 4 5 6 7 8 9 : sorted with a custom function object
9 8 7 6 5 4 3 2 1 0 : sorted with a lambda expression
```


## 103 Алгоритмы поиска find


В STL существуют следующие алгоритмы поиска:
```c++
// f - итератор на начало последовательности
// l - итератор на конец последовательности
// v - ссылка на искомое значение
// p - унарный предикат, по которому выполняется условный поиск

template<class InputIt, class T>
InputIt find(InputIt f, InputIt l, const T& v);

template<class InputIt, class UnaryPredicate>
InputIt find_if(InputIt f, InputIt l, UnaryPredicate p);

template<class InputIt, class UnaryPredicate>
InputIt find_if_not(InputIt f, InputIt l, UnaryPredicate q);
```

Пример использования:
```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main(){
    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    auto it = std::find_if(v.begin(), v.end(), 
    [](auto& x){
        return x % 2 == 0 and x % 3 == 0;
    });

    if(it == v.end()){
        std::cout << "element not found" << std::endl;
    }
    else {
        std::cout << "element: " << *it << std::endl;
    }
}
```

Результат выполнения программы:
```
element: 6
```


## 104 Алгоритмы swap


Алгоритм `swap` - алгоритм STL, выполняющий обмен значений по ссылкам.

Пример использования:
```c++
#include <iostream>
#include <algorithm>

int main(){
    int a = 10;
    int b = 20;
    
    std::cout << "B: " << a << ' ' << b << std::endl;
    std::swap(a, b);
    std::cout << "A: " << a << ' ' << b << std::endl;
}
```

Результат выполнения программы:
```
B: 10 20
A: 20 10
```

Примечание: в версии C++11 была добавлена реализация `std::swap`, перегружающая `std::swap_ranged(a, a + n, b)`.


## 105 Алгоритм merge

Алгоритм `merge` - алгоритм STL, позволяющий выполнить операцию слияния двух упорядоченных последовательностей элементов в единую последовательность:

Пример использования:
```c++
#include <algorithm>
#include <functional>
#include <iostream>
#include <iterator>
#include <random>
#include <vector>
 
auto print = [](auto const rem, auto const& v)
{
    std::cout << rem;

    std::copy(v.begin(), 
              v.end(), 
              std::ostream_iterator<int>(std::cout, " "));

    std::cout << '\n';
};
 
int main()
{
    // заполняет векторы случайными числами (random C++11)
    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<> dis(0, 9);
 
    std::vector<int> v1(10), v2(10);

    std::generate(v1.begin(), 
                 v1.end(), 
                 std::bind(dis, std::ref(mt)));
    
    std::generate(v2.begin(), 
                  v2.end(), 
                  std::bind(dis, std::ref(mt)));
 
    print("Originally:\nv1: ", v1);
    print("v2: ", v2);
 
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());
 
    print("After sorting:\nv1: ", v1);
    print("v2: ", v2);
 
    // слияние векторов
    std::vector<int> v3;
    std::merge(v1.begin(), v1.end(), 
               v2.begin(), v2.end(), 
               std::back_inserter(v3));
 
    print("After merging:\nv3: ", v3);
}
```

Результат выполнения программы:
```
Originally:
v1: 2 6 5 7 4 2 2 6 7 0
v2: 8 3 2 5 0 1 9 6 5 0
After sorting:
v1: 0 2 2 2 4 5 6 6 7 7
v2: 0 0 1 2 3 5 5 6 8 9
After merging:
v3: 0 0 0 1 2 2 2 2 3 4 5 5 5 6 6 6 7 7 8 9
```

## 106 Алгоритм for_each

Алгоритм `for_each` - алгоритм STL, позволяющий применить унарную функцию по отношению к элементам некоторой последовательности.

Пример использования:
```c++
#include <vector>
#include <algorithm>
#include <iostream>
 
struct Sum
{
    void operator()(int n) { sum += n; }
    int sum{0};
};
 
int main()
{
    std::vector<int> nums{3, 4, 2, 8, 15, 267};
 
    auto print = [](const int& n) { std::cout << " " << n; };
 
    std::cout << "before:";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';
 
    // вызывает Sum::operator() для каждого числа
    Sum s = std::for_each(nums.begin(), nums.end(), Sum());
    
    std::cout << "sum: " << s.sum << '\n';
}
```

Результат выполнения программы:
```
before: 3 4 2 8 15 267
sum: 299
```


## 107 Лямбда функции


_Лямбда-функция_ - специальный синтаксис для определения функциональных объектов, заимствованный из $\lambda$-исчисления. Применяется как правило для объявления анонимных функций по месту их использования, и обычно допускает замыкание на лексический контекст, в котором это выражение использовано.

В языке С++ лямбда-функции определяются следующим образом:
```c++
 [capture](args)specificator exception_specificator -> type {body}
```

`capture` - "захват", отвечает за то, какие данные и каким образом будут доступны в теле лямбда выражения. 

Режим записи по умолчанию можно использовать для указания способа записи любых внешних переменных, на которые ссылается текст лямбда-выражения: 
- [&] означает, что все переменные, на которые вы ссылаетесь, фиксируются по ссылке
- [=] означает, что они фиксируются по значению.

`args` - принимаемые лямбда-функцией аргументы.

`specificator` - изменяемая спецификация (например: mutable), является доп. параметром.

`exception_specificator` - спецификация исключения, дополнительный параметр.

`type` - возвращаемое значение функции.

`body` - тело лямбда-функции.


## 108 Конструктор перемещения


_Конструктор перемещения_ реализует _move-семантику_, упомянутую в _пункте 29_, и позволяет перемещать ресурсы, принадлежащие _rvalue_, в _lvalue_ без копирования.

Пример:
```c++
#include <iostream>

class Data {
public:
    explicit Data(){
        id = current_id++;
        std::cout << "Constructor "
                  << id << std::endl;
    }

    Data(const Data& other){
        id = current_id++;
        std::cout << "Copy constructor "
                  << other.id << " -> " << id << std::endl;
    }

    Data(const Data&& other) noexcept {
        id = current_id++;
        std::cout << "Move constructor "
                  << other.id << " -> " << id << std::endl;
    }

    ~Data(){
        std::cout << "Destructor "
                  << id << std::endl;
    }

private:
    static int current_id;
    int id;
};

int Data::current_id = 0;

int main(){
    Data a;                 // id 0
    Data b(a);              // id 1
    Data c(std::move(b));   // id 2
}
```

Результат выполнения программы:
```
Constructor 0
Copy constructor 0 -> 1
Move constructor 1 -> 2
Destructor2
Destructor1
Destructor0
```

В данном примере происходит следующее:
1. создается экземпляр 0;
2. создается экземпляр 1 копированием данных экземпляра 0;
3. создается экземпляр 2 переносом данных экземпляра 1;
4. вызывается деструктор для экземпляра 2;
5. вызывается деструктор для экземпляра 1;
6. вызывается деструктор для экземпляра 0.

Примечание: пункт (5) последовательности действий никак не противоречит _move-семантике_: переносится не объект, а его данные, т.е., объект не уничтожается, а принимает другое состояние, не содержащее свои прежние данные.



## 109 Оператор присваивания перемещения


Оператор присваивания перемещения имеет семантику, похожую на _конструктор перемещения_, описанный в _пункте 108_, но в отличие от него вызывается не при создании объекта, а в случаях присваивания _rvalue_ уже существующему _lvalue_.


## 110 Паттерны проектирования


_Паттерны проектирования_ - способы решения типовых задач при проектировании программы.

Паттерны проектирования обычно делятся на:
- Порождающие (фабричный метод, абстрактная фабрика, одиночка и др.)  - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
- Структурные (адаптер, мост декоратор, заместитель и др.) - отвечают за построение удобных в поддержке иерархий классов.
- Поведенческие (итератор, наблюдатель, стратегия и др.) - решают задачи эффективного и безопасного взаимодействия между объектами программы.




## 111 Паттерн "Абстрактная фабрика"


_Абстрактная фабрика_ — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

Пример:
```c++
#include <iostream>

class Shape {
public:
    virtual void draw() = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing circle instance" << std::endl;
    }
};

class Square : public Shape {
public:
    void draw() override {
        std::cout << "Drawing square instance" << std::endl;
    }
};

class Ellipse : public Shape {
public:
    void draw() override {
        std::cout << "Drawing ellipse instance" << std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing rectangle instance" << std::endl;
    }
};

class Factory {
public:
    virtual ~Factory() = default;
    // создает изогнутую фигуру
    virtual Shape* create_curved_instance() = 0;    
    // создает прямую фигуру
    virtual Shape* create_straight_instance() = 0; 
};

// создает произвольные фигуры
class SimpleShapeFactory : public Factory {
public:
    Shape* create_curved_instance() override {
        return new Ellipse;
    }

    Shape* create_straight_instance() override {
        return new Rectangle;
    }
};

// создает простые фигуры
class RobustShapeFactory : public Factory {
public:
    Shape* create_curved_instance() override {
        return new Circle;
    }

    Shape* create_straight_instance() override {
        return new Square;
    }
};

int main(){
    Factory* factory;
    Shape* shapes[6];

    factory = new SimpleShapeFactory;
    shapes[0] = factory->create_curved_instance();
    shapes[1] = factory->create_straight_instance();
    shapes[2] = factory->create_curved_instance();

    delete factory;

    factory = new RobustShapeFactory;
    shapes[3] = factory->create_curved_instance();
    shapes[4] = factory->create_straight_instance();
    shapes[5] = factory->create_curved_instance();

    for(auto& shape : shapes){
        shape->draw();
    }
}
```

Результат выполнения программы, реализующей паттерн _Абстрактная фабрика_:
```
Drawing ellipse instance
Drawing rectangle instance
Drawing ellipse instance
Drawing circle instance
Drawing square instance
Drawing circle instance
```


## 112 Умные указатели


_Умные указатели_ - абстрактный тип данных, обеспечивающий безопасное управление памятью.

В С++ существует три типа умных указателей:
- `std::unique_ptr` — умный указатель, владеющий динамически выделенным ресурсом;
- `std::shared_ptr` — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько `std::shared_ptr` могут владеть одним и тем же ресурсом, и внутренний счетчик ведет их учет;
- `std::weak_ptr` — подобен `std::shared_ptr`, но не увеличивает счетчик.

Умные указатели определены в заголовочном файле стандартной библиотеки `<memory>`.

### unique_ptr
`std::unique_ptr` владеет объектом на который он указывает и никакие другие умные указатели не могут на него указывать. 

Когда `std::unique_ptr` выходит из области видимости, объект удаляется.

Пример создания `std::unique_ptr`:

```c++
// создание обычным способом
std::unique_ptr<Type> p(new Type);

// создание с помощью функции make_unique
std::unique_ptr<Type> p = std::make_unique<Type>(params);
```

### shared_ptr

`std::shared_ptr` владеет объектом, на который он указывает, но, в отличие от `std::unique_ptr`, допускает множественные ссылки.

Специальный внутренний счетчик уменьшается каждый раз, когда `std::shared_ptr`, указывающий на тот же ресурс, выходит из области видимости. Эта техника называется подсчетом ссылок. Когда последняя из них будет уничтожена, счетчик станет равным нулю и данные будут высвобождены.

Пример создания `std::shared_ptr`:

```c++
// создание обычным способом
std::shared_ptr<Type> p(new Type);

// создание с помощью функции make_shared
std::shared_ptr<Type> p = std::make_shared<Type>(params);
```

Для получения значения счётчика указателя `std::shared_ptr` используется метод `use_count()`.

### weak_ptr

Шаблон класса описывает объект, указывающий на ресурс, управляемый одним или несколькими `shared_ptr` объектами. 

Объекты `weak_ptr` , указывающие на ресурс, не влияют на число ссылок ресурса. 

При уничтожении последнего `shared_ptr` объекта, который управляет этим ресурсом, ресурс будет освобожден, даже если есть объекты, указывающие weak_ptr на этот ресурс. Это важно для предотвращения циклов в структурах данных.

```c++
std::shared_ptr<int> p_shared = std::make_shared<int>(100);

std::weak_ptr<int> p_weak1(p_shared); // через shared_ptr
std::weak_ptr<int> p_weak2(p_weak1); // через weak_ptr
```
